<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Conceptual overview &#8212; lincs 0.8.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=96659adb"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Get started" href="get-started.html" />
    <link rel="prev" title="README" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="conceptual-overview">
<h1>Conceptual overview<a class="headerlink" href="#conceptual-overview" title="Permalink to this heading">¶</a></h1>
<p>&#64;todo(Documentation, soon) Double-check strictness of inequalities (<span class="math notranslate nohighlight">\(\lt\)</span> <em>vs.</em> <span class="math notranslate nohighlight">\(\le\)</span>) and inclusions (<span class="math notranslate nohighlight">\(\subset\)</span> <em>vs.</em> <span class="math notranslate nohighlight">\(\subseteq\)</span>) in all formal definitions in this document</p>
<section id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h2>
<p>In this document, we denote the interval of integers from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(b - 1\)</span> included by <span class="math notranslate nohighlight">\([a..b)\)</span>.
Most often, <span class="math notranslate nohighlight">\(a\)</span> will be zero.
This choice matches the indexing convention used in most modern programming language, so our documentation is as close as possible to our implementation.</p>
<p>For a given set <span class="math notranslate nohighlight">\(S\)</span>, we denote the set of all its subsets (<em>a.k.a.</em> its power set) by <span class="math notranslate nohighlight">\(\mathcal{P}(S)\)</span>.</p>
</section>
<section id="about-classification">
<h2>About classification<a class="headerlink" href="#about-classification" title="Permalink to this heading">¶</a></h2>
<p>For now, <em>lincs</em> focuses on “classification” problems, <em>i.e.</em> the task of sorting “alternatives” into “categories”.
Categories are ordered: there is a worst category and a best category, and possibly some intermediates.
Alternatives are assigned to a category based on their “performances” on a set of “criteria”.
The description of the criteria and categories constitutes the “problem” itself.</p>
<p>This vocabulary is voluntarily abstract to allow for a wide range of applications, so a concrete example might help.
Let’s say you want to assign scholarships to students based on their academic performances.
Your funding policy might be that students with the best grades should get the best scholarships.
And you might want to favor younger students, and/or students coming from more modest backgrounds.
In this example, the categories are the different scholarships, the alternatives are the students,
and the criteria are grades on each topic, age and family income.
For a given student, their performances are their actual grades on each topic, their age and their family income.</p>
<p>The same vocabulary could apply to triaging patients in an hospital based on vital signs.</p>
<div class="admonition-formal-definition admonition">
<p class="admonition-title">Formal definition</p>
<p>A problem is defined by:</p>
<ul class="simple">
<li><p>its number of criteria <span class="math notranslate nohighlight">\(n \in \mathbb{N}\)</span></p></li>
<li><p>its set of criteria <span class="math notranslate nohighlight">\(\{X_i\}_{i \in [0..n)}\)</span>. Each criterion is a set of values <span class="math notranslate nohighlight">\(X_i\)</span> with a total pre-order <span class="math notranslate nohighlight">\(\preccurlyeq_i\)</span>, for <span class="math notranslate nohighlight">\(i \in [0..n)\)</span></p></li>
<li><p>its number of categories <span class="math notranslate nohighlight">\(p \in \mathbb{N}\)</span></p></li>
<li><p>its set of categories <span class="math notranslate nohighlight">\(C = \{C^h\}_{h \in [0..p)}\)</span>, ordered by <span class="math notranslate nohighlight">\(C^0 \prec ... \prec C^{p-1}\)</span></p></li>
</ul>
<p>In that setting, alternatives are the Cartesian product of the criteria: <span class="math notranslate nohighlight">\(X = \prod_{i \in [0..n)} X_i\)</span>.
For a given alternative <span class="math notranslate nohighlight">\(x = (x_0, ..., x_{n-1}) \in X\)</span>, its performance on criterion <span class="math notranslate nohighlight">\(i\)</span> is <span class="math notranslate nohighlight">\(x_i \in X_i\)</span>.</p>
</div>
<p><em>lincs</em> stores and reads information about the classification problem using <a class="reference internal" href="reference.html#ref-file-problem"><span class="std std-ref">the YAML problem file format</span></a>.
Alternatives are stored and read using <a class="reference internal" href="reference.html#ref-file-alternatives"><span class="std std-ref">the CSV alternatives file format</span></a>.</p>
</section>
<section id="learning-and-classifying">
<h2>Learning and classifying<a class="headerlink" href="#learning-and-classifying" title="Permalink to this heading">¶</a></h2>
<p><em>lincs</em> provides algorithms to automate the classification of alternatives into categories.
Its approach is to first “learn” a “model” from a set of already classified alternatives, and then use that model to classify new alternatives.
The set of pre-classified alternatives is called the “training set”; it constitutes the ground truth for the learning phase.</p>
<p>Formally, models are functions from alternatives to category indexes: <span class="math notranslate nohighlight">\(f: X \rightarrow [0..p)\)</span>.</p>
<p>Most models are parametric functions of a given form, and the learning phase consists in finding the parameters that best fit the training set.</p>
</section>
<section id="non-compensatory-sorting-ncs">
<h2>Non-compensatory sorting (NCS)<a class="headerlink" href="#non-compensatory-sorting-ncs" title="Permalink to this heading">¶</a></h2>
<p>In general, we expect alternatives with higher performances to be assigned to better categories.
But sometimes, there are some criteria that are so important that they can’t be compensated by other criteria.
Non-compensatory sorting models are a way to capture that idea.</p>
<p>There are many “families” of models, <em>i.e.</em> sets of models that share the same general parametric form with varying parameters.
NCS models are one such family.</p>
<p>An NCS model defines a “lower performance profile” for each category.
It then assigns an alternative to a good category if that alternative has performances above that category’s lower profiles on a sufficient set of the criteria.
Sets of criteria are called “coalitions”.
NCS models allow for several ways to reach the minimum performance level to be assigned to a category,
so sufficient criteria for a category are not a <em>single</em> coalition, but actually a <em>set</em> of coalitions.
Additionally, this set of coalitions can be different for each category.</p>
<div class="admonition-formal-definition admonition">
<p class="admonition-title">Formal definition</p>
<p>An NCS model is a parametric function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\([0..p)\)</span> defined by the following parameters:</p>
<ul class="simple">
<li><p>for each category but the first, <em>i.e.</em> for <span class="math notranslate nohighlight">\(C^h\)</span> for <span class="math notranslate nohighlight">\(h \in [1..p)\)</span>:</p>
<ul>
<li><p>its lower performance profile <span class="math notranslate nohighlight">\(b^h = (b^h_0, ..., b^h_{n-1}) \in X\)</span> (do not confuse <span class="math notranslate nohighlight">\(h\)</span> for an exponent; it’s just an index)</p></li>
<li><p>its sufficient coalitions <span class="math notranslate nohighlight">\(\mathcal{F}^h \subseteq \mathcal{P}([0..n))\)</span></p></li>
</ul>
</li>
</ul>
<p>With the following constraints:</p>
<ul class="simple">
<li><p>the profiles must be ordered: <span class="math notranslate nohighlight">\(b^h_i \preccurlyeq_i b^{h + 1}_i\)</span> for each category <span class="math notranslate nohighlight">\(h \in [1..p-1)\)</span> and each criterion <span class="math notranslate nohighlight">\(i \in [0..n)\)</span></p></li>
<li><p>each category’s set of sufficient coalitions <span class="math notranslate nohighlight">\(\mathcal{F}^h\)</span> must be up-closed by inclusion: if <span class="math notranslate nohighlight">\(S \in \mathcal{F}^h\)</span> and <span class="math notranslate nohighlight">\(S \subset T \in \mathcal{P}([0..n))\)</span>, then <span class="math notranslate nohighlight">\(T \in \mathcal{F}^h\)</span></p></li>
<li><p>sufficient coalitions must be imbricated: <span class="math notranslate nohighlight">\(\mathcal{F}^1 \supseteq ... \supseteq \mathcal{F}^{p-1}\)</span></p></li>
</ul>
<p>This NCS model assigns an alternative <span class="math notranslate nohighlight">\(x = (x_0, ..., x_{n-1}) \in X\)</span> to the best category <span class="math notranslate nohighlight">\(C^h\)</span>
such that the criteria on which <span class="math notranslate nohighlight">\(x\)</span> has performances above that category’s lower profile are sufficient,
defaulting to the worst category (<span class="math notranslate nohighlight">\(C^0\)</span>):</p>
<div class="math notranslate nohighlight">
\[f: x \mapsto \max (\{0\} \cup \{ h \in [1..p): \{ i \in [0..n): x_i \succcurlyeq_i b^h_i \} \in \mathcal{F}^h \})\]</div>
</div>
<p>Note that this definition extends naturally if we denote <span class="math notranslate nohighlight">\(\mathcal{F}^0 = [0..n)\)</span> and <span class="math notranslate nohighlight">\(b^0 = (\min(X_0), ..., \min(X_{n-1}))\)</span>.
The definition of <span class="math notranslate nohighlight">\(f\)</span> then simplifies to <span class="math notranslate nohighlight">\(x \mapsto \max \{ h \in [1..p): \{ i \in [0..n): x_i \succcurlyeq_i b^h_i \} \in \mathcal{F}^h \}\)</span>.</p>
<p>This definition may differ slightly from the one you’re used to, but it should be formally equivalent.
We use it in <em>lincs</em> because it is somewhat simple and matches the implementation quite well.
We detail its equivalence to other common definitions in the following appendix:
&#64;todo(Documentation, soon) Write appendix about equivalence of definitions (<span class="math notranslate nohighlight">\(h\)</span> is shifted by 1, assignment to category is a max instead of two conditions)</p>
<p>The constraints in the definition all ensure NDS models behave according to intuition:</p>
<ul class="simple">
<li><p>the ordering of profiles ensures consistency with the order on categories</p></li>
<li><p>the up-closed-ness-by-inclusion(!) of the sufficient coalitions matches the intuition that they are <em>sufficient</em> criteria: if a few criteria are sufficient, then more criteria are still sufficient</p></li>
<li><p>the imbrication of sufficient coalitions matches the intuition that upper categories are more selective than lower ones</p></li>
</ul>
<p>NCS classification models are stored and read using <a class="reference internal" href="reference.html#ref-file-ncs-model"><span class="std std-ref">the YAML NCS model file format</span></a>.</p>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h3>
<p>Let’s continue on the scholarship example.
Let’s say there a three levels: “no scholarship” (<span class="math notranslate nohighlight">\(C^0\)</span>), “partial scholarship” (<span class="math notranslate nohighlight">\(C^1\)</span>) and “full scholarship” (<span class="math notranslate nohighlight">\(C^2\)</span>).
To further simplify things without sacrificing the interest of the example, we can consider four criteria:
grades in math (<span class="math notranslate nohighlight">\(M\)</span>), physics (<span class="math notranslate nohighlight">\(P\)</span>), literature (<span class="math notranslate nohighlight">\(L\)</span>) and history (<span class="math notranslate nohighlight">\(H\)</span>), all normalized to be between 0 and 1,
and forget about age and family income for now.</p>
<p>For clarity, we’ll use <span class="math notranslate nohighlight">\(M\)</span>, <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(H\)</span> as lower indexes instead of <span class="math notranslate nohighlight">\(i\)</span> for criteria.
Grades have the form <span class="math notranslate nohighlight">\(x = (x_M, x_P, x_L, x_H) \in X\)</span>.</p>
<p>Let’s consider the following NCS model:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b^1 = (b^1_M, b^1_P, b^1_L, b^1_H) = (0.6, 0.55, 0.7, 0.5)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{F}^1 = \{ \{M, L\}, \{M, H\}, \{P, L\}, \{P, H\}, \{M, P, L\}, \{M, P, H\}, \{M, L, H\}, \{P, L, H\}, \{M, P, L, H\} \}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(b^2 = (b^2_M, b^2_P, b^2_L, b^2_H) = (0.75, 0.9, 0.8, 0.65)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{F}^2 = \{ \{M, P, L\}, \{M, P, H\}, \{M, L, H\}, \{P, L, H\}, \{M, P, L, H\} \}\)</span></p></li>
</ul>
<p>You can check that the constraints of NCS models are satisfied:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b^1_i \preccurlyeq_i b^2_i\)</span> for <span class="math notranslate nohighlight">\(i \in \{M, P, L, H\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span> and <span class="math notranslate nohighlight">\(\mathcal{F}^2\)</span> are up-closed by inclusion</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{F}^1 \supseteq \mathcal{F}^2\)</span></p></li>
</ul>
<p>The profiles for this model look like this:</p>
<img alt="Model visualization" class="align-center" src="_images/concept-example-model.png" />
<p>The sufficient coalitions for “partial scholarship” (<em>i.e.</em> <span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span>) can be represented by:</p>
<div class="graphviz"><img src="_images/graphviz-275e9659f576fc04e5fc9c0309fff83a80c9d31f.png" alt="digraph G {
  node [shape=box,color=&quot;red&quot;,fontcolor=&quot;red&quot;];
  edge [color=&quot;red&quot;];
  rankdir=BT;
  empty -&gt; M [color=&quot;grey&quot;];
  empty -&gt; P [color=&quot;grey&quot;];
  empty -&gt; L [color=&quot;grey&quot;];
  empty -&gt; H [color=&quot;grey&quot;];
  M -&gt; MP [color=&quot;grey&quot;];
  P -&gt; MP [color=&quot;grey&quot;];
  M -&gt; ML [color=&quot;grey&quot;];
  L -&gt; ML [color=&quot;grey&quot;];
  M -&gt; MH [color=&quot;grey&quot;];
  H -&gt; MH [color=&quot;grey&quot;];
  P -&gt; PL [color=&quot;grey&quot;];
  L -&gt; PL [color=&quot;grey&quot;];
  P -&gt; PH [color=&quot;grey&quot;];
  H -&gt; PH [color=&quot;grey&quot;];
  L -&gt; LH [color=&quot;grey&quot;];
  H -&gt; LH [color=&quot;grey&quot;];
  MP -&gt; MPL [color=&quot;grey&quot;];
  MP -&gt; MPH [color=&quot;grey&quot;];
  ML -&gt; MPL [color=&quot;black&quot;];
  ML -&gt; MLH [color=&quot;black&quot;];
  MH -&gt; MPH [color=&quot;black&quot;];
  MH -&gt; MLH [color=&quot;black&quot;];
  PL -&gt; MPL [color=&quot;black&quot;];
  PL -&gt; PLH [color=&quot;black&quot;];
  PH -&gt; MPH [color=&quot;black&quot;];
  PH -&gt; PLH [color=&quot;black&quot;];
  LH -&gt; MLH [color=&quot;grey&quot;];
  LH -&gt; PLH [color=&quot;grey&quot;];
  MPL -&gt; MPLH [color=&quot;black&quot;];
  MPH -&gt; MPLH [color=&quot;black&quot;];
  MLH -&gt; MPLH [color=&quot;black&quot;];
  PLH -&gt; MPLH [color=&quot;black&quot;];

  empty [label=&lt;{}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  M [label=&lt;{&lt;i&gt;M&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  P [label=&lt;{&lt;i&gt;P&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  L [label=&lt;{&lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  H [label=&lt;{&lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  MP [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  ML [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  PL [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  PH [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  LH [label=&lt;{&lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  MPL [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MPH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MLH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  PLH [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MPLH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
}" class="graphviz" /></div>
<p><span class="math notranslate nohighlight">\(\mathcal{P}({\{M, P, L, H\}})\)</span> is represented as a lattice where arrows materialize the inclusion relationship (<span class="math notranslate nohighlight">\(\subset\)</span>).
Elements of <span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span> are black and others are grey.</p>
<p>And here are the sufficient coalitions for “full scholarship” (<em>i.e.</em> <span class="math notranslate nohighlight">\(\mathcal{F}^2\)</span>):</p>
<div class="graphviz"><img src="_images/graphviz-b58c457e1c59420eb589ce69ae1901ae958efa1e.png" alt="digraph G {
  node [shape=box,color=&quot;red&quot;,fontcolor=&quot;red&quot;];
  edge [color=&quot;red&quot;];
  rankdir=BT;
  empty -&gt; M [color=&quot;grey&quot;];
  empty -&gt; P [color=&quot;grey&quot;];
  empty -&gt; L [color=&quot;grey&quot;];
  empty -&gt; H [color=&quot;grey&quot;];
  M -&gt; MP [color=&quot;grey&quot;];
  P -&gt; MP [color=&quot;grey&quot;];
  M -&gt; ML [color=&quot;grey&quot;];
  L -&gt; ML [color=&quot;grey&quot;];
  M -&gt; MH [color=&quot;grey&quot;];
  H -&gt; MH [color=&quot;grey&quot;];
  P -&gt; PL [color=&quot;grey&quot;];
  L -&gt; PL [color=&quot;grey&quot;];
  P -&gt; PH [color=&quot;grey&quot;];
  H -&gt; PH [color=&quot;grey&quot;];
  L -&gt; LH [color=&quot;grey&quot;];
  H -&gt; LH [color=&quot;grey&quot;];
  MP -&gt; MPL [color=&quot;grey&quot;];
  MP -&gt; MPH [color=&quot;grey&quot;];
  ML -&gt; MPL [color=&quot;grey&quot;];
  ML -&gt; MLH [color=&quot;grey&quot;];
  MH -&gt; MPH [color=&quot;grey&quot;];
  MH -&gt; MLH [color=&quot;grey&quot;];
  PL -&gt; MPL [color=&quot;grey&quot;];
  PL -&gt; PLH [color=&quot;grey&quot;];
  PH -&gt; MPH [color=&quot;grey&quot;];
  PH -&gt; PLH [color=&quot;grey&quot;];
  LH -&gt; MLH [color=&quot;grey&quot;];
  LH -&gt; PLH [color=&quot;grey&quot;];
  MPL -&gt; MPLH [color=&quot;black&quot;];
  MPH -&gt; MPLH [color=&quot;black&quot;];
  MLH -&gt; MPLH [color=&quot;black&quot;];
  PLH -&gt; MPLH [color=&quot;black&quot;];

  empty [label=&lt;{}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  M [label=&lt;{&lt;i&gt;M&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  P [label=&lt;{&lt;i&gt;P&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  L [label=&lt;{&lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  H [label=&lt;{&lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  MP [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  ML [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  MH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  PL [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  PH [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  LH [label=&lt;{&lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;grey&quot;,fontcolor=&quot;grey&quot;];
  MPL [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MPH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MLH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  PLH [label=&lt;{&lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
  MPLH [label=&lt;{&lt;i&gt;M&lt;/i&gt;, &lt;i&gt;P&lt;/i&gt;, &lt;i&gt;L&lt;/i&gt;, &lt;i&gt;H&lt;/i&gt;}&gt;,color=&quot;black&quot;,fontcolor=&quot;black&quot;];
}" class="graphviz" /></div>
<p>We can now attribute scholarships to a few students according to this model.
We first look for the set of criteria where they get grades above <span class="math notranslate nohighlight">\(b^2\)</span>.
If this set is in <span class="math notranslate nohighlight">\(\mathcal{F}^2\)</span>, then they get a full scholarship.
Else, we then check if the set of criteria where they get grades above <span class="math notranslate nohighlight">\(b^1\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span>.
If yes, they get a partial scholarship.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Student</p></th>
<th class="head"><p>Grades</p></th>
<th class="head"><p>Above <span class="math notranslate nohighlight">\(b^2\)</span></p></th>
<th class="head"><p>In <span class="math notranslate nohighlight">\(\mathcal{F}^2\)</span></p></th>
<th class="head"><p>Above <span class="math notranslate nohighlight">\(b^1\)</span></p></th>
<th class="head"><p>In <span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span></p></th>
<th class="head"><p>Scholarship</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p><span class="math notranslate nohighlight">\((1, 1, 1, 1)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, P, L, H\}\)</span></p></td>
<td><p>Yes</p></td>
<td><p>(<span class="math notranslate nohighlight">\(\{M, P, L, H\}\)</span>)</p></td>
<td><p>(Yes)</p></td>
<td><p>Full</p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p><span class="math notranslate nohighlight">\((1, 1, 1, 0)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, P, L\}\)</span></p></td>
<td><p>Yes</p></td>
<td><p>(<span class="math notranslate nohighlight">\(\{M, P, L\}\)</span>)</p></td>
<td><p>(Yes)</p></td>
<td><p>Full</p></td>
</tr>
<tr class="row-even"><td><p>C</p></td>
<td><p><span class="math notranslate nohighlight">\((0.8, 0.7, 0.85, 0.6)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, L\}\)</span></p></td>
<td><p>No</p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, P, L, H\}\)</span></p></td>
<td><p>Yes</p></td>
<td><p>Partial</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p><span class="math notranslate nohighlight">\((1, 0, 1, 0)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, L\}\)</span></p></td>
<td><p>No</p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, L\}\)</span></p></td>
<td><p>Yes</p></td>
<td><p>Partial</p></td>
</tr>
<tr class="row-even"><td><p>E</p></td>
<td><p><span class="math notranslate nohighlight">\((1, 1, 0, 0)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, P\}\)</span></p></td>
<td><p>No</p></td>
<td><p><span class="math notranslate nohighlight">\(\{M, P\}\)</span></p></td>
<td><p>No</p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<p>In prose, this model can be formulated as follows:</p>
<ul class="simple">
<li><p>students who have excellent grades (above <span class="math notranslate nohighlight">\(b^2\)</span>) in at least three subjects get a full scholarship</p></li>
<li><p>students who have good grades (above <span class="math notranslate nohighlight">\(b^1\)</span>) in at least one scientific subject (<span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(P\)</span>) and at least one literary subject (<span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(H\)</span>) get a partial scholarship</p></li>
<li><p>other students get no scholarship</p></li>
</ul>
</section>
<section id="particular-cases">
<h3>Particular cases<a class="headerlink" href="#particular-cases" title="Permalink to this heading">¶</a></h3>
<p>Some particular cases are quite common.
They are NCS models with additional constraints, so they are slightly less general, but sufficient in many cases and computationally simpler to learn.</p>
<p>Here are a few that are used in <em>lincs</em>:</p>
<section id="u-c-textsf-ncs">
<h4><span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span><a class="headerlink" href="#u-c-textsf-ncs" title="Permalink to this heading">¶</a></h4>
<p>A <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> model is an NCS model where all <span class="math notranslate nohighlight">\(\mathcal{F}^h\)</span> are the same.
This simplification captures the idea that in many cases, the same criteria are sufficient for all categories, and that categories are mostly defined by their lower performance profile.</p>
<div class="admonition-formal-definition admonition">
<p class="admonition-title">Formal definition</p>
<p>A <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> model is an NCS model with the following additional constraint:</p>
<ul class="simple">
<li><p>there is a single <span class="math notranslate nohighlight">\(\mathcal{F} \subseteq \mathcal{P}([0..n))\)</span> such that <span class="math notranslate nohighlight">\(\mathcal{F}^h = \mathcal{F}\)</span> for each category <span class="math notranslate nohighlight">\(h \in [1..p)\)</span></p></li>
</ul>
</div>
<p>In the previous model example, <span class="math notranslate nohighlight">\(\mathcal{F}^1 \ne \mathcal{F}^2\)</span>, so it is not a <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> model.</p>
</section>
<section id="textsf-u-c-textsf-ncs-a-k-a-mr-sort">
<h4><span class="math notranslate nohighlight">\(1 \textsf{-} U^c \textsf{-} NCS\)</span> <em>a.k.a.</em> MR-Sort<a class="headerlink" href="#textsf-u-c-textsf-ncs-a-k-a-mr-sort" title="Permalink to this heading">¶</a></h4>
<p>An MR-Sort model is a <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> model with the additional simplification that <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is defined using weights on criteria and a threshold.
A coalition is sufficient if the sum of the weights of its criteria is above 1.</p>
<div class="admonition-formal-definition admonition">
<p class="admonition-title">Formal definition</p>
<p>An MR-Sort model is a <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> model with the following additional parameters:</p>
<ul class="simple">
<li><p>for each criterion <span class="math notranslate nohighlight">\(i \in [0..n)\)</span>:</p>
<ul>
<li><p>its weight <span class="math notranslate nohighlight">\(w_i \in [0, 1]\)</span></p></li>
</ul>
</li>
</ul>
<p>and the following additional constraint:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{F} = \{ S \in \mathcal{P}([0..n)): \sum_{i \in S} w_i \geq 1 \}\)</span></p></li>
</ul>
</div>
<p>Again, this definition differs slightly from others in the literature.
We detail their equivalence in this appendix:
&#64;todo(Documentation, soon) Write appendix about equivalence of definitions (weights are de-normalized, <span class="math notranslate nohighlight">\(\lambda\)</span> is 1)</p>
<section id="id1">
<h5>Example<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h5>
<p>Let’s consider a simplified form of our previous model example, with only the two categories <span class="math notranslate nohighlight">\(C^0\)</span> and <span class="math notranslate nohighlight">\(C^1\)</span>,
and the same profile <span class="math notranslate nohighlight">\(b^1\)</span> and sufficient coalitions <span class="math notranslate nohighlight">\(\mathcal{F}^1\)</span> as before.
Is it an MR-Sort model?
To answer this question, we can try to find weights <span class="math notranslate nohighlight">\(w_M\)</span>, <span class="math notranslate nohighlight">\(w_P\)</span>, <span class="math notranslate nohighlight">\(w_L\)</span>, <span class="math notranslate nohighlight">\(w_H\)</span> such that
<span class="math notranslate nohighlight">\(\mathcal{F}^1 = \{ S \in \mathcal{P}(\{M, P, L, H\}): \sum_{i \in S} w_i \geq 1 \}\)</span>.
This gives us <span class="math notranslate nohighlight">\(|\mathcal{P}(\{M, P, L, H\})| = 16\)</span> equations, amongst which the following 6 are of interest:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w_M + w_P \lt 1\)</span> (because <span class="math notranslate nohighlight">\(\{M, P\} \notin \mathcal{F}^1\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(w_L + w_H \lt 1\)</span> (because <span class="math notranslate nohighlight">\(\{L, H\} \notin \mathcal{F}^1\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(w_M + w_L \ge 1\)</span> (because <span class="math notranslate nohighlight">\(\{M, L\} \in \mathcal{F}^1\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(w_P + w_L \ge 1\)</span> (because <span class="math notranslate nohighlight">\(\{P, L\} \in \mathcal{F}^1\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(w_M + w_H \ge 1\)</span> (because <span class="math notranslate nohighlight">\(\{M, H\} \in \mathcal{F}^1\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(w_P + w_H \ge 1\)</span> (because <span class="math notranslate nohighlight">\(\{P, H\} \in \mathcal{F}^1\)</span>)</p></li>
</ul>
<p>Summing the first two equations gives <span class="math notranslate nohighlight">\(w_M + w_P + w_L + w_H \lt 2\)</span>, and summing teh last four gives <span class="math notranslate nohighlight">\(w_M + w_P + w_L + w_H \ge 2\)</span>,
so there is no solution, and that model is not MR-Sort.</p>
<p>By contrast, the coalitions <span class="math notranslate nohighlight">\(\mathcal{F}^2\)</span> of the previous model example can be expressed using the following weights:
<span class="math notranslate nohighlight">\(w_M = 0.4\)</span>, <span class="math notranslate nohighlight">\(w_P = 0.4\)</span>, <span class="math notranslate nohighlight">\(w_L = 0.4\)</span>, <span class="math notranslate nohighlight">\(w_H = 0.4\)</span>: coalitions of at most two criteria have weights sums less than 1,
and coalitions of at least 3 criteria have weights sums greater than 1.</p>
<p>Intuitively, MR-Sort models can express slightly fewer differences in the importance of criteria than <span class="math notranslate nohighlight">\(U^c \textsf{-} NCS\)</span> models.</p>
</section>
</section>
</section>
</section>
<section id="synthetic-data">
<h2>Synthetic data<a class="headerlink" href="#synthetic-data" title="Permalink to this heading">¶</a></h2>
<p>It’s not always practical to use real-world data when developing a new learning algorithm, so one can use synthetic data instead.
In that approach, one specifies the problem and provides a pre-known model.
They then generate pseudo-random alternatives classified according to that original model,
and use them as a training set to learn a new model.
Finally, they compare how close the learned model behaves to the original one to evaluate the quality of the algorithm.</p>
<p><em>lincs</em> provides ways to generate synthetic pseudo-random problems, models and training sets.
The same file formats are used for synthetic and real-world data.</p>
</section>
<section id="next">
<h2>Next<a class="headerlink" href="#next" title="Permalink to this heading">¶</a></h2>
<p>If you haven’t done so yet, we recommend you now follow our <a class="reference internal" href="get-started.html"><span class="doc">“Get started” guide</span></a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">lincs</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">README</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Conceptual overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notation">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-classification">About classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#learning-and-classifying">Learning and classifying</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-compensatory-sorting-ncs">Non-compensatory sorting (NCS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particular-cases">Particular cases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synthetic-data">Synthetic data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#next">Next</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="get-started.html">Get started</a></li>
<li class="toctree-l1"><a class="reference internal" href="user-guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributor-guide.html">Contributor guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">README</a></li>
      <li>Next: <a href="get-started.html" title="next chapter">Get started</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Copyright 2023 Vincent Jacques.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/conceptual-overview.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>